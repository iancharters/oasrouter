// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gorilla/mux"
)

const (
	Api_keyScopes       = "api_key.Scopes"
	Petstore_authScopes = "petstore_auth.Scopes"
)

// Defines values for OrderStatus.
const (
	Approved  OrderStatus = "approved"
	Delivered OrderStatus = "delivered"
	Placed    OrderStatus = "placed"
)

// Defines values for PetStatus.
const (
	PetStatusAvailable PetStatus = "available"
	PetStatusPending   PetStatus = "pending"
	PetStatusSold      PetStatus = "sold"
)

// Defines values for FindPetsByStatusParamsStatus.
const (
	FindPetsByStatusParamsStatusAvailable FindPetsByStatusParamsStatus = "available"
	FindPetsByStatusParamsStatusPending   FindPetsByStatusParamsStatus = "pending"
	FindPetsByStatusParamsStatusSold      FindPetsByStatusParamsStatus = "sold"
)

// ApiResponse defines model for ApiResponse.
type ApiResponse struct {
	Code    *int32  `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// Category defines model for Category.
type Category struct {
	Id   *int64  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// Order defines model for Order.
type Order struct {
	Complete *bool      `json:"complete,omitempty"`
	Id       *int64     `json:"id,omitempty"`
	PetId    *int64     `json:"petId,omitempty"`
	Quantity *int32     `json:"quantity,omitempty"`
	ShipDate *time.Time `json:"shipDate,omitempty"`

	// Status Order Status
	Status *OrderStatus `json:"status,omitempty"`
}

// OrderStatus Order Status
type OrderStatus string

// Pet defines model for Pet.
type Pet struct {
	Category  *Category `json:"category,omitempty"`
	Id        *int64    `json:"id,omitempty"`
	Name      string    `json:"name"`
	PhotoUrls []string  `json:"photoUrls"`

	// Status pet status in the store
	Status *PetStatus `json:"status,omitempty"`
	Tags   *[]Tag     `json:"tags,omitempty"`
}

// PetStatus pet status in the store
type PetStatus string

// Tag defines model for Tag.
type Tag struct {
	Id   *int64  `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// User defines model for User.
type User struct {
	Email     *string `json:"email,omitempty"`
	FirstName *string `json:"firstName,omitempty"`
	Id        *int64  `json:"id,omitempty"`
	LastName  *string `json:"lastName,omitempty"`
	Password  *string `json:"password,omitempty"`
	Phone     *string `json:"phone,omitempty"`

	// UserStatus User Status
	UserStatus *int32  `json:"userStatus,omitempty"`
	Username   *string `json:"username,omitempty"`
}

// FindPetsByStatusParams defines parameters for FindPetsByStatus.
type FindPetsByStatusParams struct {
	// Status Status values that need to be considered for filter
	Status *FindPetsByStatusParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// FindPetsByStatusParamsStatus defines parameters for FindPetsByStatus.
type FindPetsByStatusParamsStatus string

// FindPetsByTagsParams defines parameters for FindPetsByTags.
type FindPetsByTagsParams struct {
	// Tags Tags to filter by
	Tags *[]string `form:"tags,omitempty" json:"tags,omitempty"`
}

// DeletePetParams defines parameters for DeletePet.
type DeletePetParams struct {
	ApiKey *string `json:"api_key,omitempty"`
}

// UpdatePetWithFormParams defines parameters for UpdatePetWithForm.
type UpdatePetWithFormParams struct {
	// Name Name of pet that needs to be updated
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Status Status of pet that needs to be updated
	Status *string `form:"status,omitempty" json:"status,omitempty"`
}

// UploadFileParams defines parameters for UploadFile.
type UploadFileParams struct {
	// AdditionalMetadata Additional Metadata
	AdditionalMetadata *string `form:"additionalMetadata,omitempty" json:"additionalMetadata,omitempty"`
}

// CreateUsersWithListInputJSONBody defines parameters for CreateUsersWithListInput.
type CreateUsersWithListInputJSONBody = []User

// LoginUserParams defines parameters for LoginUser.
type LoginUserParams struct {
	// Username The user name for login
	Username *string `form:"username,omitempty" json:"username,omitempty"`

	// Password The password for login in clear text
	Password *string `form:"password,omitempty" json:"password,omitempty"`
}

// AddPetJSONRequestBody defines body for AddPet for application/json ContentType.
type AddPetJSONRequestBody = Pet

// AddPetFormdataRequestBody defines body for AddPet for application/x-www-form-urlencoded ContentType.
type AddPetFormdataRequestBody = Pet

// UpdatePetJSONRequestBody defines body for UpdatePet for application/json ContentType.
type UpdatePetJSONRequestBody = Pet

// UpdatePetFormdataRequestBody defines body for UpdatePet for application/x-www-form-urlencoded ContentType.
type UpdatePetFormdataRequestBody = Pet

// PlaceOrderJSONRequestBody defines body for PlaceOrder for application/json ContentType.
type PlaceOrderJSONRequestBody = Order

// PlaceOrderFormdataRequestBody defines body for PlaceOrder for application/x-www-form-urlencoded ContentType.
type PlaceOrderFormdataRequestBody = Order

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = User

// CreateUserFormdataRequestBody defines body for CreateUser for application/x-www-form-urlencoded ContentType.
type CreateUserFormdataRequestBody = User

// CreateUsersWithListInputJSONRequestBody defines body for CreateUsersWithListInput for application/json ContentType.
type CreateUsersWithListInputJSONRequestBody = CreateUsersWithListInputJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = User

// UpdateUserFormdataRequestBody defines body for UpdateUser for application/x-www-form-urlencoded ContentType.
type UpdateUserFormdataRequestBody = User

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Add a new pet to the store
	// (POST /pet)
	AddPet(w http.ResponseWriter, r *http.Request)
	// Update an existing pet
	// (PUT /pet)
	UpdatePet(w http.ResponseWriter, r *http.Request)
	// Finds Pets by status
	// (GET /pet/findByStatus)
	FindPetsByStatus(w http.ResponseWriter, r *http.Request, params FindPetsByStatusParams)
	// Finds Pets by tags
	// (GET /pet/findByTags)
	FindPetsByTags(w http.ResponseWriter, r *http.Request, params FindPetsByTagsParams)
	// Deletes a pet
	// (DELETE /pet/{petId})
	DeletePet(w http.ResponseWriter, r *http.Request, petId int64, params DeletePetParams)
	// Find pet by ID
	// (GET /pet/{petId})
	GetPetById(w http.ResponseWriter, r *http.Request, petId int64)
	// Updates a pet in the store with form data
	// (POST /pet/{petId})
	UpdatePetWithForm(w http.ResponseWriter, r *http.Request, petId int64, params UpdatePetWithFormParams)
	// uploads an image
	// (POST /pet/{petId}/uploadImage)
	UploadFile(w http.ResponseWriter, r *http.Request, petId int64, params UploadFileParams)
	// Returns pet inventories by status
	// (GET /store/inventory)
	GetInventory(w http.ResponseWriter, r *http.Request)
	// Place an order for a pet
	// (POST /store/order)
	PlaceOrder(w http.ResponseWriter, r *http.Request)
	// Delete purchase order by ID
	// (DELETE /store/order/{orderId})
	DeleteOrder(w http.ResponseWriter, r *http.Request, orderId int64)
	// Find purchase order by ID
	// (GET /store/order/{orderId})
	GetOrderById(w http.ResponseWriter, r *http.Request, orderId int64)
	// Create user
	// (POST /user)
	CreateUser(w http.ResponseWriter, r *http.Request)
	// Creates list of users with given input array
	// (POST /user/createWithList)
	CreateUsersWithListInput(w http.ResponseWriter, r *http.Request)
	// Logs user into the system
	// (GET /user/login)
	LoginUser(w http.ResponseWriter, r *http.Request, params LoginUserParams)
	// Logs out current logged in user session
	// (GET /user/logout)
	LogoutUser(w http.ResponseWriter, r *http.Request)
	// Delete user
	// (DELETE /user/{username})
	DeleteUser(w http.ResponseWriter, r *http.Request, username string)
	// Get user by user name
	// (GET /user/{username})
	GetUserByName(w http.ResponseWriter, r *http.Request, username string)
	// Update user
	// (PUT /user/{username})
	UpdateUser(w http.ResponseWriter, r *http.Request, username string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// AddPet operation middleware
func (siw *ServerInterfaceWrapper) AddPet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Petstore_authScopes, []string{"write:pets", "read:pets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddPet(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePet operation middleware
func (siw *ServerInterfaceWrapper) UpdatePet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Petstore_authScopes, []string{"write:pets", "read:pets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePet(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPetsByStatus operation middleware
func (siw *ServerInterfaceWrapper) FindPetsByStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPetsByStatusParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPetsByStatus(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPetsByTags operation middleware
func (siw *ServerInterfaceWrapper) FindPetsByTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPetsByTagsParams

	// ------------- Optional query parameter "tags" -------------

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tags", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPetsByTags(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePet operation middleware
func (siw *ServerInterfaceWrapper) DeletePet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "petId" -------------
	var petId int64

	err = runtime.BindStyledParameter("simple", false, "petId", mux.Vars(r)["petId"], &petId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "petId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeletePetParams

	headers := r.Header

	// ------------- Optional header parameter "api_key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("api_key")]; found {
		var ApiKey string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "api_key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "api_key", runtime.ParamLocationHeader, valueList[0], &ApiKey)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "api_key", Err: err})
			return
		}

		params.ApiKey = &ApiKey

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePet(w, r, petId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPetById operation middleware
func (siw *ServerInterfaceWrapper) GetPetById(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "petId" -------------
	var petId int64

	err = runtime.BindStyledParameter("simple", false, "petId", mux.Vars(r)["petId"], &petId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "petId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, Api_keyScopes, []string{})

	ctx = context.WithValue(ctx, Petstore_authScopes, []string{"write:pets", "read:pets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPetById(w, r, petId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePetWithForm operation middleware
func (siw *ServerInterfaceWrapper) UpdatePetWithForm(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "petId" -------------
	var petId int64

	err = runtime.BindStyledParameter("simple", false, "petId", mux.Vars(r)["petId"], &petId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "petId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdatePetWithFormParams

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePetWithForm(w, r, petId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadFile operation middleware
func (siw *ServerInterfaceWrapper) UploadFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "petId" -------------
	var petId int64

	err = runtime.BindStyledParameter("simple", false, "petId", mux.Vars(r)["petId"], &petId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "petId", Err: err})
		return
	}

	ctx = context.WithValue(ctx, Petstore_authScopes, []string{"write:pets", "read:pets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadFileParams

	// ------------- Optional query parameter "additionalMetadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "additionalMetadata", r.URL.Query(), &params.AdditionalMetadata)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "additionalMetadata", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadFile(w, r, petId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetInventory operation middleware
func (siw *ServerInterfaceWrapper) GetInventory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Api_keyScopes, []string{})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetInventory(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PlaceOrder operation middleware
func (siw *ServerInterfaceWrapper) PlaceOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PlaceOrder(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteOrder operation middleware
func (siw *ServerInterfaceWrapper) DeleteOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderId" -------------
	var orderId int64

	err = runtime.BindStyledParameter("simple", false, "orderId", mux.Vars(r)["orderId"], &orderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteOrder(w, r, orderId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetOrderById operation middleware
func (siw *ServerInterfaceWrapper) GetOrderById(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderId" -------------
	var orderId int64

	err = runtime.BindStyledParameter("simple", false, "orderId", mux.Vars(r)["orderId"], &orderId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderId", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOrderById(w, r, orderId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUsersWithListInput operation middleware
func (siw *ServerInterfaceWrapper) CreateUsersWithListInput(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUsersWithListInput(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LoginUser operation middleware
func (siw *ServerInterfaceWrapper) LoginUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LoginUserParams

	// ------------- Optional query parameter "username" -------------

	err = runtime.BindQueryParameter("form", true, false, "username", r.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	// ------------- Optional query parameter "password" -------------

	err = runtime.BindQueryParameter("form", true, false, "password", r.URL.Query(), &params.Password)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "password", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LoginUser(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LogoutUser operation middleware
func (siw *ServerInterfaceWrapper) LogoutUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LogoutUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameter("simple", false, "username", mux.Vars(r)["username"], &username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, username)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUserByName operation middleware
func (siw *ServerInterfaceWrapper) GetUserByName(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameter("simple", false, "username", mux.Vars(r)["username"], &username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUserByName(w, r, username)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "username" -------------
	var username string

	err = runtime.BindStyledParameter("simple", false, "username", mux.Vars(r)["username"], &username)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "username", Err: err})
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUser(w, r, username)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshallingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshallingParamError) Error() string {
	return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/pet", wrapper.AddPet).Methods("POST")

	r.HandleFunc(options.BaseURL+"/pet", wrapper.UpdatePet).Methods("PUT")

	r.HandleFunc(options.BaseURL+"/pet/findByStatus", wrapper.FindPetsByStatus).Methods("GET")

	r.HandleFunc(options.BaseURL+"/pet/findByTags", wrapper.FindPetsByTags).Methods("GET")

	r.HandleFunc(options.BaseURL+"/pet/{petId}", wrapper.DeletePet).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/pet/{petId}", wrapper.GetPetById).Methods("GET")

	r.HandleFunc(options.BaseURL+"/pet/{petId}", wrapper.UpdatePetWithForm).Methods("POST")

	r.HandleFunc(options.BaseURL+"/pet/{petId}/uploadImage", wrapper.UploadFile).Methods("POST")

	r.HandleFunc(options.BaseURL+"/store/inventory", wrapper.GetInventory).Methods("GET")

	r.HandleFunc(options.BaseURL+"/store/order", wrapper.PlaceOrder).Methods("POST")

	r.HandleFunc(options.BaseURL+"/store/order/{orderId}", wrapper.DeleteOrder).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/store/order/{orderId}", wrapper.GetOrderById).Methods("GET")

	r.HandleFunc(options.BaseURL+"/user", wrapper.CreateUser).Methods("POST")

	r.HandleFunc(options.BaseURL+"/user/createWithList", wrapper.CreateUsersWithListInput).Methods("POST")

	r.HandleFunc(options.BaseURL+"/user/login", wrapper.LoginUser).Methods("GET")

	r.HandleFunc(options.BaseURL+"/user/logout", wrapper.LogoutUser).Methods("GET")

	r.HandleFunc(options.BaseURL+"/user/{username}", wrapper.DeleteUser).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/user/{username}", wrapper.GetUserByName).Methods("GET")

	r.HandleFunc(options.BaseURL+"/user/{username}", wrapper.UpdateUser).Methods("PUT")

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"XDoAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
